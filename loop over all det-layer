#include <vector>
#include <iostream>
#include <TChain.h>
#include <TH1F.h>
#include <TGraphErrors.h>
#include <TF1.h>
#include <TCanvas.h>
#include <TString.h>
#include <TStyle.h>
#include <TLatex.h>

// Load the TChain and add relevant data files
TChain chain("treeSC");
chain.Add("/afs/cern.ch/work/n/nikiforo/public/output_485090_v1.root");
chain.Add("/afs/cern.ch/work/n/nikiforo/public/output_485950_v1.root");
chain.Add("/afs/cern.ch/work/n/nikiforo/public/output_485051_v1.root");

const int nBins = 12;
double energyBins[nBins + 1] = {5, 10, 15, 20, 25, 30, 35, 40, 50, 100, 200, 300, 500};

// Detector and layer information
const int nDetectors = 4;
const int layersPerDetector[] = {4, 4, 1, 3};  // EMB=4, EMEC=4, HEC=1 (no layer split), FCal=3
const char* detectorNames[] = {"EMB", "EMEC", "HEC", "FCal"};
const char* layerNames[] = {"Presampler", "Front", "Middle", "Back"};

std::vector<double> energyMidpoints;
std::vector<double> resolutions;
std::vector<double> errors;

// Set the style for fitting
gStyle->SetOptFit(1111);
gStyle->SetStatFormat("6.3g");  // Set stat box precision to 3 significant figures

for (int det = 0; det < nDetectors; ++det) {
    int maxLayers = layersPerDetector[det];

    for (int layer = 0; layer < maxLayers; ++layer) {
        for (int i = 0; i < nBins; ++i) {
            double energyMin = energyBins[i];
            double energyMax = energyBins[i + 1];
            double energyMidpoint = 0.5 * (energyMin + energyMax);

            TCanvas* cBin = new TCanvas(Form("cBin_det%d_layer%d_bin%d", det, layer, i), "", 800, 600);

            // Build the selection criteria
            TString cutCmd;
            if (det == 2) {  // HEC: No layer split
                cutCmd = Form("ev_et > %f && ev_et < %f && sc_det == %d", energyMin * 1000 / 12.5, energyMax * 1000 / 12.5, det);
            } else {  // Other detectors
                cutCmd = Form("ev_et > %f && ev_et < %f && sc_det == %d && sc_layer == %d", energyMin * 1000 / 12.5, energyMax * 1000 / 12.5, det, layer);
            }

            TString drawCmd = Form("ev_of_ettau/ev_of_et >> h_time_det%d_layer%d_bin%d(200, -25, 25)", det, layer, i);
            chain.Draw(drawCmd, cutCmd, "goff");

            TH1F* h_time = (TH1F*)gDirectory->Get(Form("h_time_det%d_layer%d_bin%d", det, layer, i));
            if (!h_time) {
                std::cerr << "Histogram not found for detector " << detectorNames[det] << ", layer " << layer
                          << ", energy range [" << energyMin << ", " << energyMax << "] GeV" << std::endl;
                continue;
            }

            // Perform a preliminary Gaussian fit
            h_time->Fit("gaus", "Q0");
            TF1* preFitFunction = h_time->GetFunction("gaus");

            if (preFitFunction) {
                double mean = preFitFunction->GetParameter(1);
                double sigma = preFitFunction->GetParameter(2);

                // Perform a more focused fit around the mean Â± sigma
                h_time->Fit("gaus", "Q", "", mean - sigma, mean + sigma);
                h_time->SetTitle("");
                h_time->GetXaxis()->SetTitle("Time [ns]");
                h_time->GetYaxis()->SetTitle("Counts");

                // Add detector and layer information
                TLatex info;
                info.SetTextSize(0.04);
                info.SetNDC();
                if (det == 2) {  // HEC: No layer split
                    info.DrawLatex(0.15, 0.85, Form("ATLAS LAr %s", detectorNames[det]));
                } else {  // Other detectors
                    info.DrawLatex(0.15, 0.85, Form("ATLAS LAr %s %s Layer", detectorNames[det], layerNames[layer]));
                }

                h_time->Draw();
                cBin->Update();

                TF1* fitFunction = h_time->GetFunction("gaus");
                if (fitFunction) {
                    double finalSigma = fitFunction->GetParameter(2);
                    resolutions.push_back(finalSigma);
                    energyMidpoints.push_back(energyMidpoint);
                    double error = fitFunction->GetParError(2);
                    errors.push_back(error);
                }
            }

            // Save the canvas to LXPLUS
            cBin->SaveAs(Form("/afs/cern.ch/user/s/scranepa/det%d_layer%d_bin%d.png", det, layer, i));
        }
    }
}

// Final resolution vs. energy graph and fit are omitted for brevity but can be added if needed

