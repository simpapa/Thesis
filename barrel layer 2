#include <vector>
#include <iostream>
#include <TChain.h>
#include <TH1F.h>
#include <TGraphErrors.h>
#include <TF1.h>
#include <TCanvas.h>
#include <TString.h>
#include <TStyle.h>
#include <TLatex.h>  // Include TLatex for text rendering

TChain chain("treeSC");
chain.Add("/afs/cern.ch/work/n/nikiforo/public/output_485090_v1.root");
chain.Add("/afs/cern.ch/work/n/nikiforo/public/output_485950_v1.root");
chain.Add("/afs/cern.ch/work/n/nikiforo/public/output_485051_v1.root");

const int nBins = 12;
double energyBins[nBins + 1] = {5, 10, 15, 20, 25, 30, 35, 40, 50, 100, 200, 300, 500};

std::vector<double> energyMidpoints;
std::vector<double> resolutions;
std::vector<double> errors;

gStyle->SetOptFit(1111);

for (int i = 0; i < nBins; ++i) {
    double energyMin = energyBins[i];
    double energyMax = energyBins[i + 1];
    double energyMidpoint = 0.5 * (energyMin + energyMax);

    TCanvas *cBin = new TCanvas(Form("cBin_%d", i), Form("Energy Bin %d: %.1f - %.1f GeV", i, energyMin, energyMax), 800, 600);
    
    TString drawCmd = Form("ev_of_ettau/ev_of_et >> h_time_%d(200, -25, 25)", i);
    TString cutCmd = Form("ev_et > %f && ev_et < %f && sc_layer == 2", energyMin * 1000 / 12.5, energyMax * 1000 / 12.5); // Added sc_layer == 2
    chain.Draw(drawCmd, cutCmd, "goff");

    TH1F *h_time = (TH1F*)gDirectory->Get(Form("h_time_%d", i));
    if (!h_time) {
        std::cerr << "Histogram not found for energy range: " << energyMin << " - " << energyMax << std::endl;
        continue;
    }

    h_time->Fit("gaus", "Q0");
    TF1 *preFitFunction = h_time->GetFunction("gaus");

    if (preFitFunction) {
        double mean = preFitFunction->GetParameter(1);
        double sigma = preFitFunction->GetParameter(2);
        
        h_time->Fit("gaus", "Q", "", mean - sigma, mean + sigma);
        h_time->SetTitle(Form("Time Distribution for Energy %.1f - %.1f GeV; Time (ns); Counts", energyMin, energyMax));
        h_time->Draw();
        cBin->Update();

        TF1 *fitFunction = h_time->GetFunction("gaus");
        if (fitFunction) {
            double finalSigma = fitFunction->GetParameter(2);
            resolutions.push_back(finalSigma);
            energyMidpoints.push_back(energyMidpoint);
            double error = fitFunction->GetParError(2);
            errors.push_back(error);
        }
    }
}

TGraphErrors *graph = new TGraphErrors(energyMidpoints.size(), &energyMidpoints[0], &resolutions[0], nullptr, &errors[0]);
graph->SetTitle("Resolution vs. Energy (Barrel Layer 2); Energy (GeV); Time Resolution (ns)");
graph->SetMarkerStyle(20);
graph->SetMarkerColor(kBlack); // Set points color to black

TF1 *fitCustom = new TF1("fitCustom", "[0]/x + [1]", 5, 600);
fitCustom->SetParameter(0, 1);
fitCustom->SetParameter(1, 1);

graph->Fit(fitCustom, "R");

double a = fitCustom->GetParameter(0);
double b = fitCustom->GetParameter(1);

std::cout << "Fit Parameters:" << std::endl;
std::cout << "a = " << a << " ± " << fitCustom->GetParError(0) << std::endl;
std::cout << "b = " << b << " ± " << fitCustom->GetParError(1) << std::endl;

TCanvas *c1 = new TCanvas("c1", "Resolution vs. Energy", 800, 600);
graph->Draw("AP");
fitCustom->SetLineColor(kRed); // Set the fit line color to red
fitCustom->Draw("same");

// Add the TLatex label with the formula
TLatex lat(0.5, 0.85, " #sigma_{t}(E)=#sqrt{ #frac{a^{2}}{E^{2}} + b^{2}}");
lat.SetTextSize(0.05);  // Adjust font size
lat.SetTextColor(kBlack);  // Set text color to black
lat.SetNDC();  // Use normalized device coordinates
lat.Draw();

c1->Update();
